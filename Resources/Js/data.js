let data  = [{
	"algorithm":"Bubble sort",
    "description":"Bubble sort eða stundum kallað sinking sort, er einfaldur röðunar algrímur sem fer í gegnum listan og ber saman tvær tölur hlið við hlið og svissar þeim ef þær eru ekki raðar réttar. Algrímurinn heldur þessu áfram þangað til að listinn er raðaður. Bubble sort er mjög einfaldur röðunar algrímur sem gerir hann með þeim hægustu og er ekki praktískur meðal við hina sem er í boði.",
    "codeDescription":"Algrímurinn fer í gegnum listann með for lykkju og fer síðan aftur í gegnum hann með aðrari for lykkju og mínusar index-ið sem fyrri for lykkjan er á, síðan kíkir hann og tvö stökin og ef þarf svissar þeim.",
    "codeLine":[9,15,22,22],
    "cppCode":'<p><span class="red">#include</span> <span class="blue">&lt;iostream&gt;</span></p><p><span class="red">using namespace</span> std;</p><p><span class="red">void</span></p><p><span class="blue">swap</span> (<span class="red">int</span> *xp, <span class="red">int</span> *yp)</p><p>{</p><p class="tab"><span class="red">int</span> temp = *xp;</p><p class="tab">*xp = *yp;</p><p class="tab">*yp = temp;</p><p>}</p><br><br><p><span class="red">void</span></p><p><span class="blue">bubbleSort</span> <span class="red">int</span> arr[], <span class="red">int</span> n)</p><p>{</p><p class="tab"><span class="red">int</span> i, j;</p><p class="tab">for (i = <span class="blue>0</span>; i < n - <span class="blue>1</span>; i++){</p><br><p class="tabb"><span class="red">for</span> (j = <span class="blue>0</span>; j < n - i - <span class="blue>1</span>; j++){</p><p class="tabbb"><span class="red">if</span> (arr[j] > arr[j + <span class="blue>1</span>]){</p><p class="tabbbb"><span class="blue>swap</span> (&arr[j], &arr[j + <span class="blue>1</span>]);</p><p class="tabbb">}</p><p class="tabb">}</p><p class="tab">}</p><p>}</p>',
    "cCode":'<p><span class="red">#include</span> <span class="blue">&lt;iostream&gt;</span></p><p><span class="red">using namespace</span> std;</p><p><span class="red">void</span></p><p><span class="blue">swap</span> (<span class="red">int</span> *xp, <span class="red">int</span> *yp)</p><p>{</p><p class="tab"><span class="red">int</span> temp = *xp;</p><p class="tab">*xp = *yp;</p><p class="tab">*yp = temp;</p><p>}</p><br><br><p><span class="red">void</span></p><p><span class="blue">bubbleSort</span> <span class="red">int</span> arr[], <span class="red">int</span> n)</p><p>{</p><p class="tab"><span class="red">int</span> i, j;</p><p class="tab">for (i = <span class="blue>0</span>; i < n - <span class="blue>1</span>; i++){</p><break><p class="tabb"><span class="red">for</span> (j = <span class="blue>0</span>; j < n - i - <span class="blue>1</span>; j++){</p><p class="tabbb"><span class="red">if</span> (arr[j] > arr[j + <span class="blue>1</span>]){</p><p class="tabbbb"><span class="blue>swap</span> (&arr[j], &arr[j + <span class="blue>1</span>]);</p><p class="tabbb">}</p><p class="tabb">}</p><p class="tab">}</p><p>}</p>',
    "pythonCode":'<p ><span class="orange">def</span> bubbleSort(list):</p><p class="tab">swap = <span class="orange">False</span></p><p class="tab"><span class="orange">for</span> a <span class="orange">in</span> <span class="blue">range</span>(<span class="blue">len</span>(<span class="blue">list</span>) -1):</p><p class="tabb"><span class="ornge">if</span> <span class="blue">list</span>[a] > <span class="blue">list</span>[a+1]:</p><p class="tabbb">swap = <span class="orange">True</span></p><p class="tabbb"><span class="blue">list</span>[a], <span class="blue">list</span>[a+1] = <span class="blue">list</span>[a+1], <span class="blue">list</span>[a]</p><p class="tab"><span class="orange">if not </span> swap:</p><p class="tabb"><span class="ornge">return</span> <span class="blue">list</span></p><p class="tab"><span class="blue">return</span> bubbleSort(<span class="blue">list</span>)</p>',
    "javascriptCode":'<p><span class="blue">function</span> <span class="orange">bubbleSort</span>(<span class="red">list</span>) {</p><p class="tab">  <span class="blue">let</span> swap = <span class="blue">false</span>;</p><p class="tab">    <span class="red">for</span> (<span class="blue">let</span> i = 0; i <= list.length -1; i++) {</p><p class="tabb"><span class="blue">if</span> (list[i] > list[i+1]){</p><p class="tabbb">t = list[i];</p><p class="tabbb">list[i] = list[i+1];</p><p class="tabbb">list[i+1] = t;</p><p class="tabbb">swap = <span class="blue">true</span>;</p><p class="tabb">}</p><p class="tab">}</p><p class="tab"><span class="blue">if</span> (<span class="red">!</span>swap){</p><p class="tabb"><span class="red">return</span> list;</p><p class="tab">}</p><p class="tab"><span class="red">return</span> bubbleSort(list);</p><p>}</p>'
},
{
	"algorithm":"Insertion sort",
    "description":"Insertion sort er einfaldur röðunar algrímur sem fer í gegnum listann og byggir upp raða listann einu staki í einu. Hann virkar þannig að hann fer í gegnum listann og ber stökin við það sem hann er nú þegar búin að fara í gegnum og setur það á réttan stað.",
    "codeDescription":"Algrímurinn ger í gegnum listann með for lykkju og ber hann saman við allt sem hann er nú þegar búinn að fara í gegnum með while lykkju og svissar við þörf.",
    "codeLine":[8,22,22,22],
    "cppCode":'<p><span class="red">#include</span> <bits/stdc++.h></p><p><span>using namespace</span> std;</p><br><p><span class="red">void</span> <span class="blue">insertionSort</span>(<span class="red">int</span> arr[], <span class="red">int</span> n)</p><p>{</p>  <p class="tab"><span class="red">int</span> i, key, j;</p>  <p class="tab"><span class="red">for</span> (i = <span class="blue">1</span>; i < n; i++)</p> <p class="tab">{</p>  <p class="tabb">key = arr[i];</p>  <p class="tabb">j = i - <span class="blue">1</span>;</p>  <br><p class="tabb"><span class="red">while</span> (j >= <span class="blue">0</span> && arr[j] > key)</p> <p class="tabb">{</p>  <p class="tabbb">arr[j + <span class="blue">1</span>] = arr[j];</p>  <p class="tabbb">j = j - <span class="blue">1</span>;</p>  <p class="tabb">}</p>  <p class="tabb">}</p>  arr[j + <span class="blue">1</span>] = key;</p>  <p class="tab">}</p>  }</p><p>}</p>',
    "cCode":'<p><span class="red">#include</span> <bits/stdc++.h></p><p><span>using namespace</span> std;</p><br><p><span class="red">void</span> <span class="blue">insertionSort</span>(<span class="red">int</span> arr[], <span class="red">int</span> n)</p><p>{</p>  <p class="tab"><span class="red">int</span> i, key, j;</p>  <p class="tab"><span class="red">for</span> (i = <span class="blue">1</span>; i < n; i++)</p> <p class="tab">{</p>  <p class="tabb">key = arr[i];</p>  <p class="tabb">j = i - <span class="blue">1</span>;</p>  <br><p class="tabb"><span class="red">while</span> (j >= <span class="blue">0</span> && arr[j] > key)</p> <p class="tabb">{</p>  <p class="tabbb">arr[j + <span class="blue">1</span>] = arr[j];</p>  <p class="tabbb">j = j - <span class="blue">1</span>;</p>  <p class="tabb">}</p>  <p class="tabb">}</p>  arr[j + <span class="blue">1</span>] = key;</p>  <p class="tab">}</p>  }</p><p>}</p>',
    "pythonCode":'<p><span class="orange">def</span> <span class="blue">insertionSort</span>(arr):</p><p class="tab"><span class="ornge">for</span> i <span class="ornge">in</spna> <span class="blue">range</span>(1, <span class="blue">len</span>(arr)):</p><p class="tabb">key = arr[i]</p><p class="tabb">j = i - 1</p><p class="tabb"><span class="ornge">while</span> j >= 0 <span class="ornge">and</span> key < arr[j]:</p<p class="tabbb">arr[j + 1] = arr[j]</p><p class="tabbb">j -= 1</p><p class="tabb">arr[j + 1] = key</p><p class="tab"><span class="ornge">return</span> arr</p>',
    "javascriptCode":'<p><spna class="blue">function</span> <span class="orange">insertionSort</span>(<span class="red">arr</spna>) {</p><p class="tab"><span class="blue">let</span> key, j;</p><p class="tab"><span class="blue">let</span> len = arr.length -1</p><p class="tab"><span class="red">for</spna> (<span class="blue">let</span> i = 1; i<= len; i++) {</p><p class="tabb">key = arr[i];</p><p class="tabb">j = i -1;</p><p class="tabb"><span class="blue">while</span>(j >= 0 <&& key < arr[j]){</p><p class="tabbb">arr[j + 1] = arr[j];</p><p class="tabbb">j = j - 1;</p><p class="tabb">}</p><p class="tabb">arr[j + 1] = key;</p><p class="tab">}</p><p class="tab"><span class="red">return</span> arr;</p><p>}</p>'
},
{
	"algorithm":"Selection sort",
    "description":"Selection sort er röðunar algrímur sem er svipaður insertion sort í hraða eða verr. Selection sort á erfitt með stóra lista en er frekar einfaldur. Hann semsagt fer í gegnum listann og finnur minnsta stakið og setur það fremst, hann heldur þessu áfram þangað til að listinn er raðaður.",
    "codeDescription":"Algrímurinn fer í gegum listann með for lykkju og fer síðan aftur í gegum listann frá index-inu fyrra for lykkjunnar og finnur minnsta stakið. Þegar hann finnur minnsta stakið svissar hann það sem er fremst í óraða partinum og það sem var minnst. Algrímurinn heldur þessu áfram þangað til að listinn er raðaður.",
    "codeLine":[22,22,22,22],
    "cppCode":'<p><span class="red">#include</span> <bits/stdc++.h></p> <p><span class="red">using namespace</span> std;</p><br><p><span class="red">void</span> <span class="blue">swap</span>(<span class="red">int</span> *xp, <span class="red">int</span> *yp)</p><p>{</p>  <p class="tab"><span class="red">int</span> temp = *xp;</p>  <p class="tab">*xp = *yp;</p>  <p class="tab">*yp = temp;</p><p>}</p><br><p>void selectionSort(int arr[], <span class="red">int</span> n)</p><p>{</p>  <p class="tab"><span class="red">int</span> i, j, min_idx;</p><br><p class="tab"><span class="red">for</span> (i = <span class="blue">0</span>; i < n-<span class="blue">1</span>; i++)</p<p class="tab">{</p>  <p class="tabb">min_idx = i;</p><p class="tabb"><span class="red">for</span> (j = i+<span class="blue">1</span>; j < n; j++)</p><p class="tabb"><span class="red">if</span> (arr[j] < arr[min_idx])</p> <p class="tabbb">min_idx = j;</p>  <br><p class="tabb"><span class="blue">swap</span>(&arr[min_idx], &arr[i]);</p><p class="tab">}</p>  <p>}</p>',
    "cCode":'<p><span class="red">#include</span> <bits/stdc++.h></p> <p><span class="red">using namespace</span> std;</p><br><p><span class="red">void</span> <span class="blue">swap</span>(<span class="red">int</span> *xp, <span class="red">int</span> *yp)</p><p>{</p>  <p class="tab"><span class="red">int</span> temp = *xp;</p>  <p class="tab">*xp = *yp;</p>  <p class="tab">*yp = temp;</p><p>}</p><br><p>void selectionSort(int arr[], <span class="red">int</span> n)</p><p>{</p>  <p class="tab"><span class="red">int</span> i, j, min_idx;</p><br><p class="tab"><span class="red">for</span> (i = <span class="blue">0</span>; i < n-<span class="blue">1</span>; i++)</p<p class="tab">{</p>  <p class="tabb">min_idx = i;</p><p class="tabb"><span class="red">for</span> (j = i+<span class="blue">1</span>; j < n; j++)</p><p class="tabb"><span class="red">if</span> (arr[j] < arr[min_idx])</p> <p class="tabbb">min_idx = j;</p>  <br><p class="tabb"><span class="blue">swap</span>(&arr[min_idx], &arr[i]);</p><p class="tab">}</p>  <p>}</p>',
    "pythonCode":'<p><span class="orange">def</span> <span class="blue">selectionSort</span>(A):</p><p class="tab"><span class="orange>for</span> i <span class="orange">in</span> <span class="blue">range</span>(<span class="blue">len</span>(A)):</p><p class="tabb">min_idx = i</p><p class="tabb"><span class="orange">for</span> j <span class="orange">in</span> <span class="blue">range</span>(i + 1, <span class="blue">len</span>(A)):</p><p class="tabbb"><span class="orange">if</span> A[min_idx] > A[j]:</p><p class="tabbbb">min_idx = j</p><p class="tabb">A[i], A[min_idx] = A[min_idx], A[i]</p><p><span class="orange">return</spna> A</p>',
    "javascriptCode":'<p><span class="blue">function</span><span class="red"> selectionSort<span>/(<span class="red">arr</span>) {</p><p class="tab"><span class="blue">let</span> min;</p><p class="tab"><span class="red">for</span>(<span class="blue">let</span> i = 0; i < arr.length; i++){</p><p class="tabb">min = i;</p><p class="tabb"><span class="red">for</span>(<span class="red">let</span> j = i + 1; j < arr.length; j++){</p><p class="tabbb"><span class="blue">if</span> (arr[min] > arr[j]) {</p><p class="tabbbb">min = j;</p><p class="tabbb">}</p><p class="tabb">}</p><p class="tabb">temp = arr[i];</p><p class="tabb">arr[i] = arr[min];</p><p class="tabb">arr[min] = temp;</p><p class="tab">}</p><p class="tab"><span class="red">return</spna> arr;</p><p>}</p>'
}, 
{
	"algorithm":"Counting sort",
    "description":"Counting sort er integer röðunar Algrím. í versta falli er hann o(n + k). Counting sort raðar upp tölunum frá minnstu tölunni  í stærstu sem er í listanum. Hann getur ekki raðað tölum sem eru minn en 0. Algrímið var fundið upp árið 1954 af Harold H. Seward.",
    "codeDescription":'Algrímið notfærir sér 2 lista annar er listi fyrir útkomuna, hinn er listi fyrir count. Count listinn er jafn langur og hæðsta talan í listanum sem á að sorta. Svo fer hann gegnum þrá for lykkjur, fyrsta er að raða listanum upp í count listanum, ef breitan 4 er í listanum sem á að raða myni þá 4 stakið( 4 - 1) bæta við sig 1. Miðju lykkjan er að fara gegnum allan count listan og += fyrri töluna við seinni. Sú þryðja raðar tölunum á réttan stað og retrunar sörtuð lista í lokin.',
    "codeLine":[13,20,39,39],
    "cppCode":'<p><span class="red">#include</span> <span class="blue">&lt;iostream&gt;</span></p><p><span class="red">using namespace</span> std;</p><p>int max(int arr[], int n){</p><p class="tab">int high;</p><p class="tab"><span class="red">for</span> (int i <span class="red">=</span> 0 ; i <span class="red"><</span> n ; i<span class="red">++</span>){</p><p class="tabb"><span class="red">if</span> (arr[i] <span class="red">></span> high)</p><p class="tabbb">high <span class="red">=</span> arr[i];</p><p class="tabb">}</p><p class="tab"><span class="red">return</span> high;</p><p>}</p><p>void countingSort(int <span class="red">*</span>arr, int n){</p><p class="tab">int maxNub <span class="red">=</span> max(arr, n);</p><p class="tab">int count[maxNub];</p><p class="tab"><span class="red">for</span>(int i; i <span class="red"><</span> maxNub;i<span class="red">++</span>){count[i] <span class="red">=</span> 0;}</p><p class="tab">int sort[n];</p><p class="tab"><span class="red">for</span>(int i; i <span class="red"><</span> n;i<span class="red">++</span>){sort[i] <span class="red">=</span> 0;}</p><p class="tab"><span class="red">for</span>(int i <span class="red">=</span> 0; i < n; i<span class="red">++</span>){</p><p class="tabb">count[(arr[i])<span class-"red">=</span>1] <span class="red">+=</span> 1;</p><p class="tab">}</p><p class="tab"><span class="red">for</span>(int i <span class="red">=</span> 0; i < maxNub<span class="red">-</span>1; i<span class="red">++</span>){</p><p class="tabb">count[i<span class="red">+</span>1] <span class="red">+=</span> count[i];</p><p class="tab">}</p><p class="tab"><span class="red">for</span>(int i <span class="red">=</span> 0; i <span class="red"><</span> n; i<span class="red">++</span>){</p><p class="tabb">sort[count[arr[i]<span class="red">-</span>1]<span class="red">-</span>1] <span class="red">=</span> arr[i];</p><p class="tabb">count[arr[i]<span class="red">-</span>1] <span class="red">-=</span> 1;</p><p class="tab">}</p><p class="tab">for(int i <span class="red">=</span> 0; i <span class="red"><</span> n; i<span class="red">++</span>){</p><p class="tabb">arr[i] <span class="red">=</span> sort[i];</p><p class="tab">}</p><p>}</p>',
    "cCode":'<p><span class="red">#include</span> <span class="blue">&lt;iostream&gt;</span></p><p><span class="red">using namespace</span> std;</p><p>int max(int arr[], int n){</p><p class="tab">int high;</p><p class="tab"><span class="red">for</span> (int i <span class="red">=</span> 0 ; i <span class="red"><</span> n ; i<span class="red">++</span>){</p><p class="tabb"><span class="red">if</span> (arr[i] <span class="red">></span> high)</p><p class="tabbb">high <span class="red">=</span> arr[i];</p><p class="tabb">}</p><p class="tab"><span class="red">return</span> high;</p><p>}</p><p>void countingSort(int <span class="red">*</span>arr, int n){</p><p class="tab">int maxNub <span class="red">=</span> max(arr, n);</p><p class="tab">int count[maxNub];</p><p class="tab"><span class="red">for</span>(int i; i <span class="red"><</span> maxNub;i<span class="red">++</span>){count[i] <span class="red">=</span> 0;}</p><p class="tab">int sort[n];</p><p class="tab"><span class="red">for</span>(int i; i <span class="red"><</span> n;i<span class="red">++</span>){sort[i] <span class="red">=</span> 0;}</p><p class="tab"><span class="red">for</span>(int i <span class="red">=</span> 0; i < n; i<span class="red">++</span>){</p><p class="tabb">count[(arr[i])<span class-"red">=</span>1] <span class="red">+=</span> 1;</p><p class="tab">}</p><p class="tab"><span class="red">for</span>(int i <span class="red">=</span> 0; i < maxNub<span class="red">-</span>1; i<span class="red">++</span>){</p><p class="tabb">count[i<span class="red">+</span>1] <span class="red">+=</span> count[i];</p><p class="tab">}</p><p class="tab"><span class="red">for</span>(int i <span class="red">=</span> 0; i <span class="red"><</span> n; i<span class="red">++</span>){</p><p class="tabb">sort[count[arr[i]<span class="red">-</span>1]<span class="red">-</span>1] <span class="red">=</span> arr[i];</p><p class="tabb">count[arr[i]<span class="red">-</span>1] <span class="red">-=</span> 1;</p><p class="tab">}</p><p class="tab">for(int i <span class="red">=</span> 0; i <span class="red"><</span> n; i<span class="red">++</span>){</p><p class="tabb">arr[i] <span class="red">=</span> sort[i];</p><p class="tab">}</p><p>}</p>',
    "pythonCode":'<p><span class="orange">def</span> <span class="blue">countingSort</span>(arr):</p><p class="tab">sort = [0]*<span class="blue">len</span>(arr)</p><p class="tab">count = [0]*<span class="blue">max</span>(arr)</p><p class="tab"><span class="orange">for</span> i in <span class="blue">range</span>(<span class="blue">len</span>(arr)):</p><p class="tabb">count[(arr[i])-1] += 1</p><p class="tab"><span class="orange">for</span> i in <span class="blue">range</span>(<span class="blue">len</span>(count)-1):</p><p class="tabb">count[i+1] += count[i]</p><p class="tab"><span class="orange">for</span> i in <span class="blue">range</span>(<span class="blue">len</span>(arr)):</p><p class="tabb">sort[count[arr[i]-1]-1] = arr[i]</p><p class="tabb">count[arr[i]-1] -= 1</p><p class="tab"><span class="orange">return</span> sort</p>',
    "javascriptCode":'<p><span class="blue">function</span> <span class="yellow">countingSort</span>(<span class="orange"> arr</span>){</p><p class="tab">(sort <span class="red">=</span> []).length <span class="red">=</span> arr.length;</p><p class="tab">sort.<span class="blue">fill</span>(<span class="blue">0</span>);</p><p class="tab">(count <span class="red">=</span> []).length <span class="red">=</span> <span class="blue">Math</span>.<span class="blue">max</span>(<span class="red">...</span>arr);</p><p class="tab">count.<span class="blue">fill</span>(<span class="blue">0</span>);</p><p class="tab"><span class="red">for</span>(<span class="blue">let</span> i <span class="red">=</span> 0; i < arr.length; i<span class="red">++</span>){</p><p class="tabb">count[(arr[i])-1] <span class="red">+=</span> 1;</p><p class="tab">}</p><p class="tab"><span class="red">for</span>(let i <span class="red">=</span> 0; i < count.length<span class="red">-</span>1; i<span class="red">++</span>){</p><p class="tabb">count[i<span class="red">+</span>1] <span class="red">+=</span> count[i];</p><p class="tab">}</p><p class="tab"><span class="red">for</span>(<span class="blue">let</span> i <span class="red">=</span> 0; i < arr.length; i<span class="red">++</span>){</p><p class="tabb">sort[count[arr[i]<span class="red">-</span>1]<span class="red">-</span>1] <span class="red">=</span> arr[i];</p><p class="tabb">count[arr[i]<span class="red">-</span>1] <span class="red">-=</span> 1;</p><p class="tab">}</p><p class="tab"><span class="red">return</span> sort;</p><p>}</p>'
}, 
{
	"algorithm":"Shell sort",
    "description":"Shell sort, er comparison sort algrím. Er öðruvísi útgáfa af insertion sort. Munurinn er sú að þegar insertion sort er notað og lægsta talan er út í hinum enda þá mun tala þurfa að fara í öll indexin í listanum. En með shell sort myndi talan fyrst færast í miðjuna - 1  og svo í fyrsta stakið. Tíminn fyrir shell sort er O(n2). Shell sort var fyst gefið út árið 1959 af Donald Shell.",
    "codeDescription":'Algrímið virkar þannig að hann byrjar á að finna miðjustakið í listanum, Þaðan fer hann gegnum miðjustakið út í enda, á meðan skoðar byrjar algrímið að skoða fyrsta stakið og miðjustakið ef miðju ef tala fyrri talan er stærri þá skiptir hann þeim. eftir hverja umferð er gapið deilt með 2. ',
    "codeLine":[14,18,25,25],
    "cCode":'<p>void shellSort(int arr[], int n)</p><p>{</p><p class="tab">int gap = n/2;</p><p class="tab"><span class="red">while</span>(gap <span class="red">></span> 0){</p><p class="tabb"><span class="red">for</span>(int ii <span class="red">=</span> gap; ii <span class="red"><</span> n; ii<span class="red">++</span>){</p><p class="tabbb">int temp <span class="red">=</span> arr[ii];</p><p class="tabbb">int j <span class="red">=</span> ii;</p><p class="tabbb"><span class="blue">while</span>(j <span class="red">>=</span> gap <span class="blue">&&</span> arr[j <span class="red">-</span>gap] <span class="red">></span> temp){</p><p class="tabbbb">arr[j] <span class="red">=</span> arr[j<span class="red">-</span>gap];</p><p class="tabbbb">j <span class="red">-=</span> gap;</p><p class="tabbb">}</p><p class="tabbb">arr[j] <span class="red">=</span> temp;</p><p class="tabb">}</p><p class="tabb">gap <span class="red">=</span> gap<span class="red">/</span>2;</p><p class="tab">}</p><p>}</p><p>int main()</p><p>{</p><p class="tab">int arr[5] = { 12, 34, 54, 2, 3};</p><p class="tab">shellSort(arr, 5);</p><p class="tab"><span class="red',
    "cppCode":'<p>void shellSort(int arr[], int n)</p><p>{</p><p class="tab">int gap = n/2;</p><p class="tab"><span class="red">while</span>(gap <span class="red">></span> 0){</p><p class="tabb"><span class="red">for</span>(int ii <span class="red">=</span> gap; ii <span class="red"><</span> n; ii<span class="red">++</span>){</p><p class="tabbb">int temp <span class="red">=</span> arr[ii];</p><p class="tabbb">int j <span class="red">=</span> ii;</p><p class="tabbb"><span class="blue">while</span>(j <span class="red">>=</span> gap <span class="blue">&&</span> arr[j <span class="red">-</span>gap] <span class="red">></span> temp){</p><p class="tabbbb">arr[j] <span class="red">=</span> arr[j<span class="red">-</span>gap];</p><p class="tabbbb">j <span class="red">-=</span> gap;</p><p class="tabbb">}</p><p class="tabbb">arr[j] <span class="red">=</span> temp;</p><p class="tabb">}</p><p class="tabb">gap <span class="red">=</span> gap<span class="red">/</span>2;</p><p class="tab">}</p><p>}</p>',
    "pythonCode":'<p><span class="orange">def</span> <span class="blue">shellSort</span>(arr):</p><p class="tab"> n = <span class="blue">len</span>(arr)</p><p class="tab">gap = n//2</p><p class="tab"><span class="orange">while</span> gap > 0:</p><p class="tabb"><span class="orange">for</span> i <span class="orange">in</span> <span class="blue">range</span>(gap, n):</p><p class="tabbb">  temp = arr[i]</p><p class="tabbb">j = i</p><p class="tabbb"><span class="orange">while</span>  j >= gap <span class="orange">and</span> arr[j-gap] >temp:</p><p class="tabbbb">arr[j] = arr[j-gap]</p><p  class="tabbbb">j -= gap</p><p  class="tabbb">arr[j] = temp</p> <p class="tabb">gap //= 2</p>',
    "javascriptCode":'<p><span class="blue">function</span> <span class="blue">shellSort</span>(arr){</p><p class="tab"><span class="blue">let</span> n = arr.<span class="blue">length</span>;</p><p class="tab"><span class="blue">let</span> gap = Math.<span class="blue">floor</span>(n /2);</p><p class="tab"><span class="blue">while</span>(gap > 0){</p><p class="tabb"><span class="blue">for</span>(<span class="blue">let</span> i = gap;i < n; i++){</p><p class="tabbb"><span class="blue">let</span> temp = arr[i];</p><p class="tabbb"><span class="blue">let</span> j = i;</p><p class="tabbb"><span class="blue">while</span>(j >= gap & arr[j-gap] > temp){</p><p class="tabbbb">arr[j] = arr[j-gap];</p><p class="tabbbb">j -= gap;</p><p class="tabbb">}</p><p class="tabbb">arr[j] = temp;</p><p class="tabb">}</p><p class="tabb">gap = Math.<span class="blue">floor</span>(gap/2);</p><p class="tab">}</p><p>}</p>'
},
{
	"algorithm":"Quick sort",
	"description":"Quick sort er skilvirkur röðunar algrímur sem var hannaður af breska tölvunarfræðinginum Tony Hoare árið 1959 og var birtur árið 1961. Quick sort er enn notaður í dag og ef forritaður rétt getur hann verið um 2 til 3 sinnum hraðvirkari en keppunautar hans sem eru merge sort og heap sort. Quick sort virkar þannig að hann er divide and conquer algrímur. Hann semsagt velur sér pivot tölu deilir listanum í tvennt og setur tölurnar sem eru minni einum meginn og stærri hinum megin og recursively raðar partaða listana.",
    "codeDescription":"Algrímurinn velur sér pivot tölu og flokkar listann í tvo parta, einn sem er með tölur minni en pivot talan og einn sem er stærri. Hann fer síðan öðrum megin heldur síðan áfram recursively og síðan hinum megin.",
	"codeLine":[22,22,22,22],
    "cppCode":'<p><span class="red">#include</span><stdio.h></p><p><span class="red">#include</span> <bits/stdc++.h></p><br><p><span class="red">void</span> <span class="blue">swap</span>(<span class="red">int</span>* a, <span class="red">int</span>* b)</p> <p>{</p> <p class="tab"><span class="red">int</span> t = *a;</p><p class="tab">*a = *b;</p> <p class="tab">*b = t;</p> <p>}</p> <br><p><span class="red">int</span> <span class="blue">partition</span> (<span class="red">int</span> arr[], <span class="red">int</span> low, <span class="red">int</span> high)</p><p>{</p> <p class="tab"><span class="red">int</span> pivot = arr[high];</p><p class="tab"><span class="red">int</span> i = (low - <span class="blue">1</span>);</p><br><p class="tab"><span class="red">for</span> (<span class="red">int</span> j = low; j <= high- <span class="blue">1</span>; j++)</p><p class="tab">{</p> <p class="tabb"><span class="red">if</span> (arr[j] <= pivot)</p> <p class="tabb">{</p> <p class="tabbb">i++;</p>   <p class="tabbb"><span class="blue">swap</span>(&arr[i], &arr[j]);</p> <p class="tabb">}</p> <p class="tab">}</p> <p class="tab"><span class="blue">swap</span>(&arr[i + <span class="blue">1</span>], &arr[high]);</p><p class="tab"><span class="red">return</span> (i + <span class="blue">1</span>);</p><p>}</p> <br><p><span class="red">void</span> <span class="blue">quickSort</span>(<span class="red">int</span> arr[], <span class="red">int</span> low, <span class="red">int</span> high)</p> <p>{</p> <p class="tab"><span class="red">if</span> (low < high)</p><p class="tab">{</p> <p class="tabb"><span class="red">int</span> pi = <span class="blue">partition</span>(arr, low, high);</p> <br><p class="tabb"><span class="blue">quickSort</span>(arr, low, pi - <span class="blue">1</span>);</p><p class="tabb"><span class="blue">quickSort</span>(arr, pi + <span class="blue">1</span>, high);</p> <p class="tab">}</p> <p>}</p>',
	"cCode":'<p><span class="red">#include</span><stdio.h></p><p><span class="red">#include</span> <bits/stdc++.h></p><br><p><span class="red">void</span> <span class="blue">swap</span>(<span class="red">int</span>* a, <span class="red">int</span>* b)</p> <p>{</p> <p class="tab"><span class="red">int</span> t = *a;</p><p class="tab">*a = *b;</p> <p class="tab">*b = t;</p> <p>}</p> <br><p><span class="red">int</span> <span class="blue">partition</span> (<span class="red">int</span> arr[], <span class="red">int</span> low, <span class="red">int</span> high)</p><p>{</p> <p class="tab"><span class="red">int</span> pivot = arr[high];</p><p class="tab"><span class="red">int</span> i = (low - <span class="blue">1</span>);</p><br><p class="tab"><span class="red">for</span> (<span class="red">int</span> j = low; j <= high- <span class="blue">1</span>; j++)</p><p class="tab">{</p> <p class="tabb"><span class="red">if</span> (arr[j] <= pivot)</p> <p class="tabb">{</p> <p class="tabbb">i++;</p>   <p class="tabbb"><span class="blue">swap</span>(&arr[i], &arr[j]);</p> <p class="tabb">}</p> <p class="tab">}</p> <p class="tab"><span class="blue">swap</span>(&arr[i + <span class="blue">1</span>], &arr[high]);</p><p class="tab"><span class="red">return</span> (i + <span class="blue">1</span>);</p><p>}</p> <br><p><span class="red">void</span> <span class="blue">quickSort</span>(<span class="red">int</span> arr[], <span class="red">int</span> low, <span class="red">int</span> high)</p> <p>{</p> <p class="tab"><span class="red">if</span> (low < high)</p><p class="tab">{</p> <p class="tabb"><span class="red">int</span> pi = <span class="blue">partition</span>(arr, low, high);</p> <br><p class="tabb"><span class="blue">quickSort</span>(arr, low, pi - <span class="blue">1</span>);</p><p class="tabb"><span class="blue">quickSort</span>(arr, pi + <span class="blue">1</span>, high);</p> <p class="tab">}</p> <p>}</p>',
	"pythonCode":'<p><span class="orange">def</span> <span class="blue">partition</span>(arr, low, high):</p><p class="tab">i = (low - 1)</p><p class="tab">pivot = arr[high]</p><p class="tab"><span class="orange">for</span> j <span class="orange">in</span> <span class="blue">range</span>(low, high):</p><p class="tabb"><span class="orange">if</span> arr[j] <= pivot:</p><p class="tabbb">i = i + 1</p><p class="tabbbb">arr[i], arr[j] = arr[j], arr[i]</p><p class="tab">arr[i + 1], arr[high] = arr[high], arr[i + 1]</p><p class="tab"><span class="orange">return</span> i + 1</p><p><span class="orange">def</span> <span class="blue">quickSort</span>(arr, low, high):</p><p class="tab"><span class="orange">if</span> low < high:</p><p class="tabb">pi = partition(arr, low, high)</p><p class="tabb">quickSort(arr, low, pi - 1)</p><p class="tabb">quickSort(arr, pi + 1, high)</p>',
	"javascriptCode":'<p><span class="blue">function</span> <span class="red">partition</span>(<span class="red">arr</span>, <span class="red">low</span>, <span class="red">high</span>) {</p><p class="tab"><span class="blue">let</span> temp;</p><p class="tab">i = (low - 1);</p><p class="tab">pivot = arr[high]</p><p class="tab"><span class="red">for</span>(<span class="blue">let</span> j = low; j < high; j++){</p><p class="tabb"><span class="blue">if</span> (arr[j] <= pivot) {</p><p class="tabbb">i = i + 1;</p><p class="tabbb">temp = arr[i];</p><p class="tabbb">arr[i] = arr[j];</p><p class="tabbb">arr[j] = temp;</p><p class="tabb">}</p><p class="tab">}</p><p class="tab">temp = arr[i + 1];</p><p class="tab">arr[i + 1] = arr[high];</p><p class="tab">arr[high] = temp;</p><p class="tab"><span class="red">return</span> i + 1</p><p>}</p><p><span class="blue">function</span> <span class="red">quickSort</span>(arr, low=0, high=null) {</p><p class="tab"><span class="red">if</span> (high == <span class="blue">null</span>) {</p><p  class="tabb">high = arr.length -1;</p><p  class="tab">}</p><p class="tab"><span class="blue">if</span> (low < high) {</p><p class="tabb">pi = partition(arr, low, high);</p><p class="tabb">quickSort(arr, low, pi - 1);</p><p class="tabb">quickSort(arr, pi + 1, high);</p><p class="tab">}</p><p>}</p>'
},
{
	"algorithm":"Heap sort",
    "description":"Heap sorter comparison röðunar algrím, byggt á Binary Heap data structure. Hepsort byrjarað finna hæstu töluna og færa hann frem, þegar fremst tala er sú hæsta færir hana aftast og þá er hún röðuð. Tíminn á heap sort o(nLogn). Heap sort var fundið af J. W. J. Williams árið 1964.",
    "codeDescription":"Algríð virka þannig að, það notar heapify að búa til maxheap(hæðsta talan fremst), þegar maxheap er til færir hann toluna aftast og leitar svo aftur af maxheapi, þegar hann finnur það fer hún næsta aftast og svo koll á kolli þangað til að listinn er raðaður.",
    "codeLine":[24,31,40,40],
    "cppCode":'<p><span class="yellow">void</span> heapify(int arr[], int n, int i)</p><p>{</p><p class="tab">int largest = i;</p><p class="tab">int l <span class="red">=</span> 2 <span class="red">*</span> i <span class="red">+</span> 1;</p><p class="tab">int r <span class="red">=</span> 2 <span class="red">*</span> i <span class="red">+</span> 2;</p><p class="tab"><span class="red">if</span>(l <span class="red"><</span> n & arr[i] <span class="red"><</span> arr[l]){</p><p class="tabb">largest <span class="red">=</span> l;</p><p class="tab">}</p><p class="tab"><span class="red">if</span>(r <span class="red"><</span> n & arr[largest] <span class="red"><</span> arr[r]){</p><p class="tabb">largest <span class="red">=</span> r;</p><p class="tab">}</p><p class="tab"><span class="red">if</span>(largest != i){</p><p class="tabb">int temp <span class="red">=</span> arr[i];</p><p class="tabb">arr[i] <span class="red">=</span> arr[largest];</p><p class="tabb">arr[largest] <span class="red">=</span> temp;</p><p class="tabb">heapify(arr, n, largest);</p><p class="tab">}</p><p>}</p><p><span class="yellow">void</span> heapSort(int arr[], int n)</p><p>{</p><p class="tab"><span class="red">for</span>(int i <span class="red">=</span> n; i <span class="red">></span> <span class="red">-</span>1; i<span class="red">--</span>){</p><p class="tabb">heapify(arr, n, i);</p><p class="tab">}</p><p class="tab"><span class="red">for</span>(int i <span class="red">=</span> n<span class="red">-</span>1; i <span class="red">></span> 0; i<span class="red">--</span>){</p><p class="tabb">int temp <span class="red">=</span> arr[i];</p><p class="tabb">arr[i] <span class="red">=</span> arr[0];</p><p class="tabb">arr[0] <span class="red">=</span> temp;</p><p class="tabb">heapify(arr, i, 0);</p><p class="tab">}</p><p>}</p>',
    "cCode":'<p><span class="yellow">void</span> heapify(int arr[], int n, int i)</p><p>{</p><p class="tab">int largest = i;</p><p class="tab">int l <span class="red">=</span> 2 <span class="red">*</span> i <span class="red">+</span> 1;</p><p class="tab">int r <span class="red">=</span> 2 <span class="red">*</span> i <span class="red">+</span> 2;</p><p class="tab"><span class="red">if</span>(l <span class="red"><</span> n & arr[i] <span class="red"><</span> arr[l]){</p><p class="tabb">largest <span class="red">=</span> l;</p><p class="tab">}</p><p class="tab"><span class="red">if</span>(r <span class="red"><</span> n & arr[largest] <span class="red"><</span> arr[r]){</p><p class="tabb">largest <span class="red">=</span> r;</p><p class="tab">}</p><p class="tab"><span class="red">if</span>(largest != i){</p><p class="tabb">int temp <span class="red">=</span> arr[i];</p><p class="tabb">arr[i] <span class="red">=</span> arr[largest];</p><p class="tabb">arr[largest] <span class="red">=</span> temp;</p><p class="tabb">heapify(arr, n, largest);</p><p class="tab">}</p><p>}</p><p><span class="yellow">void</span> heapSort(int arr[], int n)</p><p>{</p><p class="tab"><span class="red">for</span>(int i <span class="red">=</span> n; i <span class="red">></span> <span class="red">-</span>1; i<span class="red">--</span>){</p><p class="tabb">heapify(arr, n, i);</p><p class="tab">}</p><p class="tab"><span class="red">for</span>(int i <span class="red">=</span> n<span class="red">-</span>1; i <span class="red">></span> 0; i<span class="red">--</span>){</p><p class="tabb">int temp <span class="red">=</span> arr[i];</p><p class="tabb">arr[i] <span class="red">=</span> arr[0];</p><p class="tabb">arr[0] <span class="red">=</span> temp;</p><p class="tabb">heapify(arr, i, 0);</p><p class="tab">}</p><p>}</p>',
    "pythonCode":'<p><span class="orange">def</span> <span class="blue">heapify</span>(arr, n, i):</p><p class="tab">largest = i</p><p class="tab">l = 2 * i + 1</p><p class="tab">r = 2 * i + 2</p><p class="tab"><span class="orange">if</span> l < n <span class="orange">and</span> arr[i] < arr[l]:</p><p class="tabb">largest = l</p><p class="tab"><span class="orange">if</span> r < n <span class="orange">and</span> arr[largest] < arr[r]:</p><p class="tabb">largest = r</p><p class="tab"><span class="orange">if</span> largest != i:</p><p class="tabb">temp = arr[i]</p><p class="tabb">arr[i] = arr[largest]</p><p class="tabb">arr[largest] = temp</p><p class="tabb">heapify(arr, n, largest)</p><p><span class="orange">def</span> <span class="blue">heapSort</span>(arr):</p><p class="tab">n = len(arr)</p><p class="tab"><span class="orange">for</span> i <span class="orange">in</span> range(n, -1, -1):</p><p class="tabb">heapify(arr, n, i)</p><p class="tab"><span class="orange">for</span> i <span class="orange">in</span> range(n-1, 0, -1):</p><p class="tabb">temp = arr[i]</p><p class="tabb">arr[i] = arr[0]</p><p class="tabb">arr[0] = temp</p><p class="tabb">heapify(arr, i, 0)</p>',
    "javascriptCode":'<p><span class="blue">function</span> <span class="blue">heapify</span>(arr, n, i){</p><p class="tab"><span class="blue">let</span> largest = i</p><p class="tab"><span class="blue">let</span> l = 2 * i + 1</p><p class="tab"><span class="blue">let</span> r = 2 * i + 2</p><p class="tab"><span class="blue">if</span>(l < n & arr[i] < arr[l]){</p> <p class="tabb">largest = l</p><p class="tab">}</p><p class="tab"><span class="blue">if</span>(r < n & arr[largest] < arr[r]){</p> <p class="tabb">largest = r</p><p class="tab">}</p><p class="tab"><span class="blue">if</span>(largest != i){</p><p class="tabb">temp = arr[i]</p><p class="tabb">arr[i] = arr[largest]</p><p class="tabb">arr[largest] = temp</p><p class="tabb">heapify(arr, n, largest)</p><p class="tab">}</p><p>}</p><p><span class="blue">function</span> <span class="blue">heapSort</span>(arr){</p><p class="tab">n = arr.<span class="blue">length</span>;</p><p class="tab"><span class="blue">for</span>(i = n; i > -1; i--){</p><p class="tabb">heapify(arr, n, i)</p><p class="tab">}</p><p class="tab"><span class="blue">for</span>(i = n-1; i > 0; i--){</p><p class="tabb">temp = arr[i]</p><p class="tabb">arr[i] = arr[0]</p><p class="tabb">arr[0] = temp</p><p class="tabb">heapify(arr, i, 0)</p><p class="tab">}</p><p>}</p>'
},
{
	"algorithm":"Merge sort",
    "description":"Merge Sort er  Divide and Conquer algrím. Algrímið skiptir listanum í 2 þangað til að listinn er með 1 index þá ber hann listana samann og raðar þeim rétt. Tíma á Merge sort er o(n log(n)). Var fundið árið 1948 af von Neumann.",
    "codeDescription":"Algrímið skiptir listanum upp í 2 þagnað til að hann er með 1 stak í listanum, þá ver hann til baka og raður upp stokunum, Ef listinn er [3,2,1,6] myndi ferlið vera [3,2,1,6] - [3,2],[1,6] - [3], [2], [1], [6] - [2,3], [1,6] - [1,2,3,6]",
    "codeLine":[26,35,33,33],
    "cppCode":'<p>void mergeSort(<span class="red">int</span> arr[], <span class="red">int</span> l, <span class="red">int</span> m, <span class="red">int</span> r){</p><p class="tab"><span class="red">int</span> i, j, k;</p><p class="tab"><span class="red">int</span> n1 = m - l + 1;</p><p class="tab"><span class="red">int</span> n2 =  r - m;</p><p class="tab"><span class="red">int</span> L[n1], R[n2];</p><p class="tab"><span class="red">for</span> (i = 0; i < n1; i++)</p><p class="tabb">L[i] = arr[l + i];</p><p class="tab"><span class="red">for</span> (j = 0; j < n2; j++)</p><p class="tabb">R[j] = arr[m + 1+ j];</p><p class="tab">i = 0;</p><p class="tab">j = 0;</p><p class="tab">k = l;</p><p class="tab"><span class="red">while</span> (i < n1 && j < n2){</p><p class="tabb"><span class="red">if</span> (L[i] <= R[j]){</p><p class="tabbb">arr[k] = L[i];</p><p class="tabbb">i++;</p><p class="tabb">}<span class="red">else</span>{</p><p class="tabbb">arr[k] = R[j];</p><p class="tabbb">j<span class="red">++</span>;</p><p class="tabb">}</p><p class="tabb">k<span class="red">++</span>;</p><p class="tab">}</p><p class="tab"><span class="red">while</span> (i < n1){</p><p class="tabb">arr[k] = L[i];</p><p class="tabbb">i<span class="red">++</span>;</p><p class="tabb">k<span class="red">++</span>;</p><p class="tab">}</p><p class="tab"><span class="red">while</span> (j < n2){</p><p class="tabb">arr[k] = R[j];</p><p class="tabb">j<span class="red">++</span>;</p><p class="tabb">k<span class="red">++</span>;</p><p class="tab">}</p><p>}</p>',
    "cCode":'<p>void mergeSort(<span class="red">int</span> arr[], <span class="red">int</span> l, <span class="red">int</span> m, <span class="red">int</span> r){</p><p class="tab"><span class="red">int</span> i, j, k;</p><p class="tab"><span class="red">int</span> n1 = m - l + 1;</p><p class="tab"><span class="red">int</span> n2 =  r - m;</p><p class="tab"><span class="red">int</span> L[n1], R[n2];</p><p class="tab"><span class="red">for</span> (i = 0; i < n1; i++)</p><p class="tabb">L[i] = arr[l + i];</p><p class="tab"><span class="red">for</span> (j = 0; j < n2; j++)</p><p class="tabb">R[j] = arr[m + 1+ j];</p><p class="tab">i = 0;</p><p class="tab">j = 0;</p><p class="tab">k = l;</p><p class="tab"><span class="red">while</span> (i < n1 && j < n2){</p><p class="tabb"><span class="red">if</span> (L[i] <= R[j]){</p><p class="tabbb">arr[k] = L[i];</p><p class="tabbb">i++;</p><p class="tabb">}<span class="red">else</span>{</p><p class="tabbb">arr[k] = R[j];</p><p class="tabbb">j<span class="red">++</span>;</p><p class="tabb">}</p><p class="tabb">k<span class="red">++</span>;</p><p class="tab">}</p><p class="tab"><span class="red">while</span> (i < n1){</p><p class="tabb">arr[k] = L[i];</p><p class="tabbb">i<span class="red">++</span>;</p><p class="tabb">k<span class="red">++</span>;</p><p class="tab">}</p><p class="tab"><span class="red">while</span> (j < n2){</p><p class="tabb">arr[k] = R[j];</p><p class="tabb">j<span class="red">++</span>;</p><p class="tabb">k<span class="red">++</span>;</p><p class="tab">}</p><p>}</p>',
    "pythonCode":'<p><span class="orange">def</span> <span class="blue">mergeSort</span>(arr):</p><p class="tab"><span class="orange">if</span> <span class="blue">len</span>(arr) >1:</p><p class="tabb">mid = <span class="blue">len</span>(arr)//2</p><p class="tabb">L = arr[:mid]</p><p class="tabb">R = arr[mid:]</p><p class="tabb">mergeSort(L)</p><p class="tabb">mergeSort(R)</p><p class="tabb">i = j = k = 0</p><p class="tabb"><span class="orange">while</span> i < <span class="blue">len</span>(L) and j < <span class="blue">len</span>(R):</p><p class="tabbb"><span class="orange">if</span> L[i] < R[j]:</p><p class="tabbbb">arr[k] = L[i]</p><p class="tabbbb">i+=1</p><p class="tabbb"><span class="orange">else</span>:</p><p class="tabbbb">arr[k] = R[j]</p><p class="tabbbb">j+=1</p><p class="tabbb">k+=1</p><p class="tabb"><span class="orange">while</span> i < <span class="blue">len</span>(L):</p><p class="tabbb">arr[k] = L[i]</p><p class="tabbb">i+=1</p><p class="tabbb">k+=1</p><p class="tabb"><span class="orange">while</span> j < <span class="blue">len</span>(R):</p><p class="tabbb">arr[k] = R[j]</p><p class="tabbb">j+=1</p><p class="tabbb">k+=1</p>',
    "javascriptCode":'<p ><span class="blue">function mergeSort</span>(arr) {</p><p class="tab"><span class="blue">let</span> n = arr.<span class="blue">length</span>;</p><p class="tab">if(n > 1){</p><p class="tabb"><span class="blue">let</span> mid = Math.<span class="blue">floor</span>(n/2);</p><p class="tabb"><span class="blue">let</span> l = arr.<span class="blue">slice</span>(0, mid);</p><p class="tabb"><span class="blue">let</span> r = arr.<span class="blue">slice</span>(mid, n);</p><p class="tabb">mergeSort(l);</p><p class="tabb">mergeSort(r);</p><p class="tabb"><span class="blue">let</span> i = 0;</p><p class="tabb"><span class="blue">let</span> j = 0;</p><p class="tabb"><span class="blue">let</span> k = 0;</p><p class="tabb"><span class="blue">while</span>(i < l.<span class="blue">length</span> & j < r.<span class="blue">length</span>){</p><p class="tabbb"><span class="blue">if</span>(l[i] < r[j]){</p><p class="tabbbb">arr[k] = l[i];</p><p class="tabbbb">i+=1</p><p class="tabbb">}<span class="blue">else</span>{</p><p class="tabbbb">arr[k] = r[j];</p><p class="tabbbb">j+=1</p><p class="tabbb">}</p><p class="tabbb">k+=1</p><p class="tabb">}</p><p class="tabb"><span class="blue">while</span>(i < l.<span class="blue">length</span>){</p><p class="tabbb">arr[k] = l[i];</p><p class="tabbb">i+=1</p><p class="tabbb">k+=1</p><p class="tabb">}</p><p class="tabb"><span class="blue">while</span>(j < r.<span class="blue">length</span>){</p><p class="tabbb">arr[k] = r[j];</p><p class="tabbb">j+=1</p><p class="tabbb">k+=1</p><p class="tabb">}</p><p class="tab">}</p><p >}</p>'
}
];
